// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.1
// source: recommendation.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { makeGenericClientConstructor, } from "@grpc/grpc-js";
export const protobufPackage = "recommendation";
function createBaseRecommendationRequest() {
    return { topics: [], skill_level: "", preferred_duration: "", limit: 0 };
}
export const RecommendationRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.topics) {
            writer.uint32(10).string(v);
        }
        if (message.skill_level !== "") {
            writer.uint32(18).string(message.skill_level);
        }
        if (message.preferred_duration !== "") {
            writer.uint32(26).string(message.preferred_duration);
        }
        if (message.limit !== 0) {
            writer.uint32(32).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecommendationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.topics.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.skill_level = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.preferred_duration = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e) => globalThis.String(e)) : [],
            skill_level: isSet(object.skill_level) ? globalThis.String(object.skill_level) : "",
            preferred_duration: isSet(object.preferred_duration) ? globalThis.String(object.preferred_duration) : "",
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.topics?.length) {
            obj.topics = message.topics;
        }
        if (message.skill_level !== "") {
            obj.skill_level = message.skill_level;
        }
        if (message.preferred_duration !== "") {
            obj.preferred_duration = message.preferred_duration;
        }
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        return obj;
    },
    create(base) {
        return RecommendationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecommendationRequest();
        message.topics = object.topics?.map((e) => e) || [];
        message.skill_level = object.skill_level ?? "";
        message.preferred_duration = object.preferred_duration ?? "";
        message.limit = object.limit ?? 0;
        return message;
    },
};
function createBaseCourseRecommendation() {
    return {
        title: "",
        description: "",
        category: "",
        skill_level: "",
        duration: "",
        instructor: "",
        relevance_score: 0,
        topics: [],
    };
}
export const CourseRecommendation = {
    encode(message, writer = new BinaryWriter()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.category !== "") {
            writer.uint32(26).string(message.category);
        }
        if (message.skill_level !== "") {
            writer.uint32(34).string(message.skill_level);
        }
        if (message.duration !== "") {
            writer.uint32(42).string(message.duration);
        }
        if (message.instructor !== "") {
            writer.uint32(50).string(message.instructor);
        }
        if (message.relevance_score !== 0) {
            writer.uint32(61).float(message.relevance_score);
        }
        for (const v of message.topics) {
            writer.uint32(66).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCourseRecommendation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.category = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.skill_level = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.duration = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.instructor = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 61) {
                        break;
                    }
                    message.relevance_score = reader.float();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.topics.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            category: isSet(object.category) ? globalThis.String(object.category) : "",
            skill_level: isSet(object.skill_level) ? globalThis.String(object.skill_level) : "",
            duration: isSet(object.duration) ? globalThis.String(object.duration) : "",
            instructor: isSet(object.instructor) ? globalThis.String(object.instructor) : "",
            relevance_score: isSet(object.relevance_score) ? globalThis.Number(object.relevance_score) : 0,
            topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.category !== "") {
            obj.category = message.category;
        }
        if (message.skill_level !== "") {
            obj.skill_level = message.skill_level;
        }
        if (message.duration !== "") {
            obj.duration = message.duration;
        }
        if (message.instructor !== "") {
            obj.instructor = message.instructor;
        }
        if (message.relevance_score !== 0) {
            obj.relevance_score = message.relevance_score;
        }
        if (message.topics?.length) {
            obj.topics = message.topics;
        }
        return obj;
    },
    create(base) {
        return CourseRecommendation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCourseRecommendation();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.category = object.category ?? "";
        message.skill_level = object.skill_level ?? "";
        message.duration = object.duration ?? "";
        message.instructor = object.instructor ?? "";
        message.relevance_score = object.relevance_score ?? 0;
        message.topics = object.topics?.map((e) => e) || [];
        return message;
    },
};
function createBaseRecommendationResponse() {
    return { recommendations: [], message: "", total_count: 0 };
}
export const RecommendationResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.recommendations) {
            CourseRecommendation.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.total_count !== 0) {
            writer.uint32(24).int32(message.total_count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecommendationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.recommendations.push(CourseRecommendation.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.total_count = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            recommendations: globalThis.Array.isArray(object?.recommendations)
                ? object.recommendations.map((e) => CourseRecommendation.fromJSON(e))
                : [],
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            total_count: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.recommendations?.length) {
            obj.recommendations = message.recommendations.map((e) => CourseRecommendation.toJSON(e));
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.total_count !== 0) {
            obj.total_count = Math.round(message.total_count);
        }
        return obj;
    },
    create(base) {
        return RecommendationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecommendationResponse();
        message.recommendations = object.recommendations?.map((e) => CourseRecommendation.fromPartial(e)) || [];
        message.message = object.message ?? "";
        message.total_count = object.total_count ?? 0;
        return message;
    },
};
export const RecommendationServiceService = {
    /** Get course recommendations based on user preferences */
    getRecommendations: {
        path: "/recommendation.RecommendationService/GetRecommendations",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(RecommendationRequest.encode(value).finish()),
        requestDeserialize: (value) => RecommendationRequest.decode(value),
        responseSerialize: (value) => Buffer.from(RecommendationResponse.encode(value).finish()),
        responseDeserialize: (value) => RecommendationResponse.decode(value),
    },
};
export const RecommendationServiceClient = makeGenericClientConstructor(RecommendationServiceService, "recommendation.RecommendationService");
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=recommendation.js.map